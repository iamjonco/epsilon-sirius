import 'EcoreUtil.eol';
import 'SiriusUtil.eol';

pre {
	// Setup inital structures	
	// TODO: Handle multiple Groups
	var topGroup : new ODesign!viewpoint::description::Group;
	topGroup.name := getDiagramClass().name;
	
	// TODO: Handle multiple Viewpoints
	var topViewpoint : new ODesign!viewpoint::description::Viewpoint;
	topViewpoint.name := getDiagramClass().name;
	topViewpoint.modelFileExtension := 
		getDiagramClass().getAnnotationValue('gmf.diagram','model.extension').ifUndefined('*');
	topGroup.ownedViewpoints.add(topViewpoint);
	
	// Setup Default Colors
	var DEFAULT_PALETTE : ODesign!viewpoint::description::UserColorsPalette := 
		new ODesign!UserColorsPalette;
	DEFAULT_PALETTE.name := 'Default';
		
	topGroup.userColorsPalettes.add(DEFAULT_PALETTE);
	
	var DEFAULT_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_COLOR', 211, 211, 211);
	var DEFAULT_LINE_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_LINE', 0, 0, 0);
	var DEFAULT_BORDER_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_BORDER', 0, 0, 0);
	var DEFAULT_LABEL_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_LABEL', 0, 0, 0);

	DEFAULT_PALETTE.entries.add(DEFAULT_COLOR);
	DEFAULT_PALETTE.entries.add(DEFAULT_LINE_COLOR);
	DEFAULT_PALETTE.entries.add(DEFAULT_BORDER_COLOR);
	DEFAULT_PALETTE.entries.add(DEFAULT_LABEL_COLOR);
}

post {
	// Assign top level diagram mappings
	var topMappings := getDiagramClass()
		.getEAllContainments()
		.collect(r|r.eReferenceType)
		.collect(t|t.getConcreteSubMappings())
		.flatten();
	
	var layer := getDiagramClass().equivalent('EClass2DiagramDescription').defaultLayer; // TODO: Handle multiple layers
	for (mapping in topMappings) {
		if (mapping.isMapped())
			layer.reusedMappings.add(mapping);
		else if (mapping.isKindOf(ODesign!ContainerMapping))
			layer.containerMappings.add(mapping);
		else
			layer.nodeMappings.add(mapping);
	}
	
	// Assign container mappings
	for (class in ECore!EClass) {
		var topMapping := class.getMapping();
		if (topMapping.isUndefined()) continue; // FIXME: Current gets the diagram class too
	
		var subMappings := class
			.getEAllContainments()
			.collect(r|r.eReferenceType)
			.collect(t|t.getConcreteSubMappings())
			.flatten();
			
		for (mapping in subMappings) {
			if (mapping.isMapped()) 
				if (mapping.isKindOf(ODesign!ContainerMapping)) 
					topMapping.reusedContainerMappings.add(mapping);
				else 
					topMapping.reusedNodeMappings.add(mapping);
					
			else if (mapping.isKindOf(ODesign!ContainerMapping))
				topMapping.subContainerMappings.add(mapping);
			else 
				topMapping.subNodeMappings.add(mapping);
		}
	}
}

// TODO: Handle multiple metamodel imports
// TODO: do we need multiple tool sections?
// FIXME: Href link in metamodel that is generated is not well formatted
// TODO: Handle multiple layers - probs should be the nodes that set it
rule EClass2DiagramDescription
	transform s : ECore!EClass
	to t : ODesign!diagram::description::DiagramDescription {
	guard: s.isAnnotatedAs('gmf.diagram')
	
	topViewpoint.ownedRepresentations.add(t);
	
	t.name := s.getAnnotationValue('gmf.diagram', 'label').ifUndefined('Diagram');
	t.domainClass = s.getDomainClassString();
	t.metamodel.add(s.ePackage);
	
	// Setup Layers
	// TODO: handle additional layering
	var layer := new ODesign!Layer;
	layer.name := 'Default';
	t.defaultLayer := layer;
}

/**
 * ============================================================================
 * SEMANTIC MAPPINGS
 * ============================================================================
 */

/**
 * Abstract base rule for mappings between EClass's and DiagramElements.
 * 
 * Sets up constraints to restrict the creation of elements
 */
@abstract
rule EClass2Mapping
	transform s : ECore!EClass
	to t : ODesign!diagram::description::AbstractNodeMapping {
	guard: s.isNode() or s.isLink()
	
	// Setup creation constraints
	t.name := s.name;
	t.domainClass := s.getDomainClassString();
	t.semanticCandidatesExpression := "eol:self.eContents";
	t.preconditionExpression := "eol:self.isTypeOf(Model!" + s.getDomainClassString() + ")";
}

rule EClass2ContainerMapping
	transform s : ECore!EClass
	to t : ODesign!diagram::description::ContainerMapping
	extends EClass2Mapping {
	guard: s.isNode() and s.hasCompartments()
}

rule EClass2NodeMapping
	transform s : ECore!EClass
	to t : ODesign!diagram::description::NodeMapping 
	extends EClass2Mapping {
	guard: s.isNode() and not s.hasCompartments()
}

rule ElementLink
	transform s : ECore!EClass
	to t : ODesign!diagram::description::EdgeMapping
	extends EClass2Mapping {
	guard: s.isLink()
	
	var ann := s.getAnnotation('gmf.link');
	
	getDiagramClass().equivalent().defaultLayer.edgeMappings.add(t);
	

	t.useDomainElement := true;
	
	// Determine source mappings
	var sourceDet := ann.getDetail('source');
	var sourceFeature := s.eStructuralFeatures.selectOne(sf|sf.name = sourceDet);
	t.sourceMapping.addAll(sourceFeature.eType.getConcreteSubMappings());
	t.sourceFinderExpression := 'feature:' + sourceDet;
	
	var targetDet := ann.getDetail('target');
	var targetFeature := s.eStructuralFeatures.selectOne(sf|sf.name = targetDet);
	t.targetMapping.addAll(targetFeature.eType.getConcreteSubMappings());
	t.targetFinderExpression := 'feature:' + targetDet;
	
	t.style := new ODesign!EdgeStyleDescription;	
}

rule RelationLink
	transform s : ECore!EReference
	to t : ODesign!diagram::description::EdgeMapping {
	guard: s.isLink()
	
	getDiagramClass().equivalent().defaultLayer.edgeMappings.add(t);
	
	var source := s.eContainingClass.getConcreteSubMappings();
	var target := s.eReferenceType.getConcreteSubMappings();
	
	t.name := source.name + '2' + target.name;
	t.useDomainElement := false;
	// TODO: account for subtypes as well
	t.sourceMapping.addAll(source);
	t.targetMapping.addAll(target);
	t.targetFinderExpression := 'feature:' + s.name;
	
	t.style := new ODesign!EdgeStyleDescription;
}

/**
 * ============================================================================
 * STYLE DESCRIPTIONS
 * ============================================================================
 */
@abstract
rule EClass2LabelStyleDescription
	transform s : ECore!EClass
	to t : ODesign!diagram::description::LabelStyleDescription {
	guard: s.isNode()
	
	t.labelExpression := s.getLabelExpression();
	
	var colorDet := s.getAnnotationValue('gmf.node', 'label.color');
	if (colorDet.isDefined()) t.labelColor := newColor(s.name + '_LABEL', colorDet);
	else t.labelColor := DEFAULT_LABEL_COLOR;
}

@abstract
rule EClass2BorderdStyleDescription
	transform s : ECore!EClass
	to t : ODesign!diagram::description::BorderedStyleDescription {
	guard: s.isNode()
	
	// Border Line Style
	var lineDet := s.getAnnotationValue('gmf.node', 'border.style');
	var line : Any;
	switch (lineDet) {
		case 'dot': t.borderLineStyle := ODesign!diagram::LineStyle#dot;
		case 'dash': t.borderLineStyle := ODesign!diagram::LineStyle#dash;
		case 'dash_dot': t.borderLineStyle := ODesign!diagram::LineStyle#dash_dot;
		default: t.borderLineStyle := ODesign!diagram::LineStyle#solid;
	}
	
	// Border Color
	var colorDet := s.getAnnotationValue('gmf.node', 'border.color');
	if (colorDet.isDefined()) t.borderColor := newColor(s.name + '_BORDER', colorDet);
	else t.borderColor := DEFAULT_BORDER_COLOR;
}

@abstract
rule EClass2NodeStyleDescription 
	transform s : ECore!EClass
	to t : ODesign!NodeStyleDescription
	extends EClass2LabelStyleDescription, EClass2BorderdStyleDescription {
	guard: s.isNode() and not s.hasCompartments()
	
	s.equivalent('EClass2NodeMapping').style := t;
}

@abstract
rule EClass2NodeStyleWithColor 
	transform s : ECore!EClass
	to t : ODesign!NodeStyleDescription
	extends EClass2NodeStyleDescription {
	
	var colorDet := s.getAnnotationValue('gmf.node', 'color');
	if (colorDet.isDefined()) t.color := newColor(s.name + '_COLOR', colorDet);
	else t.color := DEFAULT_COLOR;
}

rule EClass2SquareDescription
	transform s : ECore!EClass
	to t : ODesign!SquareDescription
	extends EClass2NodeStyleWithColor {
	guard: s.getAnnotationValue('gmf.node', 'shape') == 'square'
}

rule EClass2LozengeNodeDescription
	transform s : ECore!EClass
	to t : ODesign!LozengeNodeDescription
	extends EClass2NodeStyleWithColor {
	guard: s.getAnnotationValue('gmf.node', 'shape') == 'diamond'
	
	t.heightComputationExpression := "[view.name.size()+5/]";
	t.widthComputationExpression := "[view.name.size()+5/]";
}

rule EClass2EllipseNodeDescription
	transform s : ECore!EClass
	to t : ODesign!EllipseNodeDescription
	extends EClass2NodeStyleWithColor {
	// FIXME: Can probably simplify this guard
	guard: s.getAnnotationValue('gmf.node', 'shape') == 'ellipse' 
		or s.getAnnotationValue('gmf.node', 'shape') == null

	t.horizontalDiameterComputationExpression := "[view.name.size()+3/]";
	t.verticalDiameterComputationExpression := "4";
}

rule EClass2FlatContainerStyleDescription
	transform s : ECore!EClass
	to t : ODesign!FlatContainerStyleDescription
	extends EClass2LabelStyleDescription, EClass2BorderdStyleDescription {
	guard: s.isNode() and s.hasCompartments()
	
	s.equivalent('EClass2ContainerMapping').style := t;
}

/**
 * ============================================================================
 * TOOLS
 * ============================================================================
 */
 
rule NodeTool 
	transform s : ECore!EClass
	to t : ODesign!NodeCreationDescription {
	guard: s.isNode() and s.getCompartmentReferences().isEmpty()
	
	var ann := s.getAnnotation('gmf.node');

	// Get the tool section
	var toolSection := getDiagramClass().equivalent().defaultLayer.toolSections
		.selectOne(t|t.name = 'Node');
	if (toolSection.isUndefined()) {
		toolSection := new ODesign!ToolSection;
		toolSection.name := 'Node';
		getDiagramClass().equivalent().defaultLayer.toolSections.add(toolSection);
	}
	toolSection.ownedTools.add(t);
	
	// Initialise mappings
	t.nodeMappings.add(s.equivalents().selectOne(n|n.isTypeOf(ODesign!NodeMapping)));
		
	// Initialise default container variables
	t.name := s.name;
	t.variable := new ODesign!NodeCreationVariable;
	t.variable.name := "container";
	t.viewVariable := new ODesign!ContainerViewVariable;
	t.viewVariable.name := "containerView";
	
	// Build the operation
	var path := s.getContainmentPath();

	var rootOp := new ODesign!InitialNodeCreationOperation;
	t.initialOperation := rootOp;

	var contextOp := new ODesign!ChangeContext;
	rootOp.firstModelOperations := contextOp;
	contextOp.browseExpression := "eol:self";
	var i = path.size() - 1;
	while (i > 0) {
		contextOp.browseExpression += ',' + path[i];
		i := i - 1;
	}
		
	var createOp := new ODesign!CreateInstance;
	contextOp.subModelOperations.add(createOp);
	createOp.typeName := s.getDomainClassString();
	createOp.referenceName := path[0];	
}

/**
 * ============================================================================
 * HELPER OPERATIONS
 * ============================================================================
 */

@cached
operation ECore!EClass getContainmentPath() : Collection {
	var toVisit := new Sequence;
	var visited := new Set;
	var propertyMap := new Map;
	toVisit.add(getDiagramClass());
	propertyMap.put(getDiagramClass(), null);
	
	while (toVisit.notEmpty()) {
		var current := toVisit.first();
		visited.add(current);
		toVisit.remove(current);
		
		var refs := current.getContainmentReferences();
		for (r in refs) {
			var property := Sequence{current, r};
			propertyMap.put(r.eType, property);
			
			if (self.eAllSuperTypes.includes(r.eType) or self = r.eType) {
				return resolveContainmentPath(r.eType, propertyMap);
			}
		
			if (visited.excludes(r.eType)) {
				toVisit.add(r.eType);
			}
		}
	}
}

operation ODesign!AbstractNodeMapping isMapped() : Boolean {
	return self.eContainer.isDefined() 
		and (self.eContainer.isTypeOf(ODesign!Layer) 
		or self.eContainer.isKindOf(ODesign!ContainerMapping));
}

operation resolveContainmentPath(start, propertyMap) : Collection {
	var path := new Sequence;
	var eType := start;	
	var notFinished := true;
	
	while(notFinished) {
		var property := propertyMap.get(eType);
		if (property.isDefined()) {
			eType := property.first();
			path.add(property.second().name);
		} else {
			notFinished = false;
		}
	}
	return path;
}

@cached
operation ECore!EClass getConcreteSubMappings() : Collection {
	return self.getConcreteSubtypes()
		.flatten()
		.collect(t|t.getMapping())
		.select(m|m.isDefined());
}

@cached
operation ECore!EClass getMapping() : ODesign!AbstractNodeMapping {
	return self.equivalent('EClass2ContainerMapping', 'EClass2NodeMapping');
}