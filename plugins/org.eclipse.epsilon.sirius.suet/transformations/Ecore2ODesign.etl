import 'EcoreUtil.eol';
import 'SiriusUtil.eol';

pre {
	// Setup inital structures	
	// TODO: Handle multiple Groups
	var topGroup : new ODesign!viewpoint::description::Group;
	topGroup.name := getDiagramClass().name;
	
	// TODO: Handle multiple Viewpoints
	var topViewpoint : new ODesign!viewpoint::description::Viewpoint;
	topViewpoint.name := getDiagramClass().name;
	topViewpoint.modelFileExtension := 
		getDiagramClass().getAnnotationValue('gmf.diagram','model.extension').ifUndefined('*');
	topGroup.ownedViewpoints.add(topViewpoint);
	
	// Setup Default Colors
	var DEFAULT_PALETTE : ODesign!viewpoint::description::UserColorsPalette := 
		new ODesign!UserColorsPalette;
	DEFAULT_PALETTE.name := 'Default';
		
	topGroup.userColorsPalettes.add(DEFAULT_PALETTE);
	
	var DEFAULT_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_COLOR', 211, 211, 211);
	var DEFAULT_LINE_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_LINE', 0, 0, 0);
	var DEFAULT_BORDER_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_BORDER', 0, 0, 0);
	var DEFAULT_LABEL_COLOR : ODesign!viewpoint::description::UserFixedColor :=
		newColor('DEFAULT_LABEL', 0, 0, 0);

	DEFAULT_PALETTE.entries.add(DEFAULT_COLOR);
	DEFAULT_PALETTE.entries.add(DEFAULT_LINE_COLOR);
	DEFAULT_PALETTE.entries.add(DEFAULT_BORDER_COLOR);
	DEFAULT_PALETTE.entries.add(DEFAULT_LABEL_COLOR);
}

// TODO: Handle multiple metamodel imports
// TODO: do we need multiple tool sections?
// FIXME: Href link in metamodel that is generated sucks
// TODO: Handle multiple layers - probs should be the nodes that set it
rule Diagram
	transform s : ECore!EClass
	to t : ODesign!diagram::description::DiagramDescription {
	guard: s.isAnnotatedAs('gmf.diagram')
	
	var ann := s.getAnnotation('gmf.diagram');

	t.name := s.getAnnotationValue('gmf.diagram', 'label').ifUndefined('Diagram');
	t.domainClass = s.getDomainClassString();
	t.metamodel.add(s.ePackage);
	
	// Setup Layers
	// TODO: handle additional layering
	t.defaultLayer := new ODesign!Layer;
	t.defaultLayer.name := 'Default';

	topViewpoint.ownedRepresentations.add(t);
}

rule Node 
	transform s : ECore!EClass
	to t : ODesign!diagram::description::NodeMapping {
	guard: s.isNode()
	
	var ann := s.getAnnotation('gmf.node');

	// TODO: Handle multi diagrams
	getDiagramClass().equivalent().defaultLayer.nodeMappings.add(t);
	
	// Setup creation constraints
	t.name := s.name; // Diagram Description ID/Label - not shown to end user
	t.domainClass := s.getDomainClassString();
	t.semanticCandidatesExpression := "eol:" + s.name +".allOfType";
	t.preconditionExpression := "eol:self.type().name = '" + s.name + "'";	
	
	// Style - initial setup
	// TODO: Account for all the other shapes/icons
	var style : ODesign!NodeStyleDescription;
	var shape := ann.getDetail('shape');
	if (shape = "square") {
		style := new ODesign!SquareDescription;
	}
	else if (shape = "diamond") {
		style := new ODesign!LozengeNodeDescription;
		style.heightComputationExpression := "[view.name.size()+5/]";
		style.widthDiameterComputationExpression := "[view.name.size()+5/]";
	}
	else {
		style := new ODesign!EllipseNodeDescription;
		style.horizontalDiameterComputationExpression := "[view.name.size()+3/]";
		style.verticalDiameterComputationExpression := "4";
	}
	
	t.style := style;
	
	var colorDet := ann.getDetail('color');
	if (colorDet.isDefined()) {
		t.style.color := newColor(s.name + '_COLOR', colorDet);
	} else {
		t.style.color := DEFAULT_COLOR;
	}
	
	var resizeable := ann.getDetail('resizeable').ifUndefined(true);
	if (resizeable.asBoolean()) {
		t.style.resizeKind := ODesign!diagram::ResizeKind#NSEW;
	} else {
		t.style.resizeKind := ODesign!diagram::ResizeKind#NONE;
	}
	
	// Style - Borders
	var borderColorDet := ann.getDetail('border.color');
	if (borderColorDet.isDefined()) {
		t.style.borderColor := newColor(s.name + '_BORDER', borderColorDet);
	} else {
		t.style.borderColor := DEFAULT_BORDER_COLOR;
	}
	
	var borderStyleDet := ann.getDetail('border.style');
	var borderStyle : Any;
	switch (borderStyleDet) {
		case 'dot': borderStyle := ODesign!diagram::LineStyle#dot;
		case 'dash': borderStyle := ODesign!diagram::LineStyle#dash;
		case 'dash_dot': borderStyle := ODesign!diagram::LineStyle#dash_dot;
		default: borderStyle := ODesign!diagram::LineStyle#solid;
	}
	t.style.borderLineStyle := borderStyle;

	// Style - Labelling
	// TODO: style.hideLabelByDefault 
	t.style.labelExpression := s.getLabelExpression(); // FIXME: Not sure this works correctly
	t.style.labelPosition := s.getLabelPlacement();
	
	var labelColorDet := ann.getDetail('label.color');
	if (labelColorDet.isDefined()) {
		t.style.labelColor := newColor(s.name + '_LABEL', labelColorDet);
	} else {
		t.style.labelColor := DEFAULT_LABEL_COLOR;
	}
}

rule NodeTool 
	transform s : ECore!EClass
	to t : ODesign!NodeCreationDescription {
	guard: s.isNode()
	
	var ann := s.getAnnotation('gmf.node');

	// Get the tool section
	var toolSection := getDiagramClass().equivalent().defaultLayer.toolSections
		.selectOne(t|t.name = 'New');
	if (toolSection.isUndefined()) {
		toolSection := new ODesign!ToolSection;
		toolSection.name := 'New';
		getDiagramClass().equivalent().defaultLayer.toolSections.add(toolSection);
	}
	toolSection.ownedTools.add(t);
	
	// Initialise mappings
	t.nodeMappings.add(s.equivalents().selectOne(n|n.type().name = 'NodeMapping'));
		
	// Initialise default container variables
	t.name := "Create" + s.name;
	t.variable := new ODesign!NodeCreationVariable;
	t.variable.name := "container";
	t.viewVariable := new ODesign!ContainerViewVariable;
	t.viewVariable.name := "containerView";
	
	// Build the operation
	var path := s.getContainmentPath();

	var rootOp := new ODesign!InitialNodeCreationOperation;
	t.initialOperation := rootOp;

	var contextOp := new ODesign!ChangeContext;
	rootOp.firstModelOperations := contextOp;
	contextOp.browseExpression := "eol:self";
	var i = path.size() - 1;
	while (i > 0) {
		contextOp.browseExpression += ',' + path[i];
		i := i - 1;
	}
		
	var createOp := new ODesign!CreateInstance;
	contextOp.subModelOperations.add(createOp);
	createOp.typeName := s.getDomainClassString();
	createOp.referenceName := path[0];	
}

@cached
operation ECore!EClass getContainmentPath() : Sequence {
	var toVisit := new Sequence;
	var visited := new Set;
	var propertyMap := new Map;
	toVisit.add(getDiagramClass());
	propertyMap.put(getDiagramClass(), null);
	
	while (toVisit.notEmpty()) {
		var current := toVisit.first();
		visited.add(current);
		toVisit.remove(current);
		
		var refs := current.getContainmentReferences();
		for (r in refs) {
			var property := Sequence{current, r};
			propertyMap.put(r.eType, property);
			
			if (self.eAllSuperTypes.includes(r.eType) or self = r.eType) {
				return resolveContainmentPath(r.eType, propertyMap);
			}
		
			if (visited.excludes(r.eType)) {
				toVisit.add(r.eType);
			}
		}
	}
}

operation resolveContainmentPath(start, propertyMap) : Sequence {
	var path := new Sequence;
	var eType := start;	
	var notFinished := true;
	
	while(notFinished) {
		var property := propertyMap.get(eType);
		if (property.isDefined()) {
			eType := property.first();
			path.add(property.second().name);
		} else {
			notFinished = false;
		}
	}
	
	return path;
}